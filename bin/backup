#!/usr/bin/env python

from datetime import date
from itertools import chain
from optparse import OptionParser
import os
import Queue
import random
import subprocess
import sys
from threading import Thread
import yaml

PROGDIR = os.path.abspath(os.path.dirname(__file__))
CODABACKUP = os.path.join(PROGDIR, 'codabackup')
RBDBACKUP = os.path.join(PROGDIR, 'rbdbackup')
RGWBACKUP = os.path.join(PROGDIR, 'rgwbackup')
RSYNCBACKUP = os.path.join(PROGDIR, 'rsyncbackup')


class Task(object):
    def run(self):
        print ' '.join(self.command)
        subprocess.check_call(self.command, close_fds=True)


class Source(object):
    def __init__(self, config):
        self._settings = config.get('settings', {})
        self._manifest = config.get(self.LABEL, {})
        self._queue = Queue.Queue()
        self._thread_count = self._settings.get('%s-workers' % self.LABEL, 1)
        self._threads = []

    @classmethod
    def get_sources(cls):
        sources = {}
        for subclass in cls.__subclasses__():
            if hasattr(subclass, 'LABEL'):
                sources[subclass.LABEL] = subclass
        return sources

    def start(self):
        for n in range(self._thread_count):
            thread = Thread(target=self._worker)
            thread.start()
            self._threads.append(thread)

    def _worker(self):
        while True:
            try:
                task = self._queue.get_nowait()
            except Queue.Empty:
                return
            task.run()

    def wait(self):
        for thread in self._threads:
            thread.join()
        self._threads = []


class BucketTask(Task):
    def __init__(self, settings, name, force_s3_acls=False):
        Task.__init__(self)
        out_dir = os.path.join(settings['root'], 'rgw', name)
        self.command = [sys.executable, RGWBACKUP, '-v',
                settings['rgw-server'], name, out_dir]
        if settings.get('rgw-secure', False):
            self.command.append('-s')
        if force_s3_acls:
            self.command.append('-A')


class RGWSource(Source):
    LABEL = 'rgw'

    def __init__(self, config, options):
        Source.__init__(self, config)
        for name in self._manifest:
            self._queue.put(BucketTask(self._settings, name,
                    force_s3_acls='rgw-force-acls' in options))


class ImageTask(Task):
    SECTION = 'images'

    def __init__(self, settings, pool, name, friendly_name):
        Task.__init__(self)
        out_path = os.path.join(settings['root'], 'rbd', pool,
                self.SECTION, friendly_name)
        self.command = [sys.executable, RBDBACKUP, pool, name, out_path]


class SnapshotTask(ImageTask):
    SECTION = 'snapshots'

    def __init__(self, settings, pool, name, friendly_name):
        ImageTask.__init__(self, settings, pool, name, friendly_name)
        self.command.append('-s')


class RBDSource(Source):
    LABEL = 'rbd'

    def __init__(self, config, options):
        Source.__init__(self, config)
        for pool, info in self._manifest.get('images', {}).items():
            for friendly_name, name in info.items():
                self._queue.put(ImageTask(self._settings, pool, name,
                        friendly_name))
        for pool, info in self._manifest.get('snapshots', {}).items():
            for friendly_name, name in info.items():
                self._queue.put(SnapshotTask(self._settings, pool, name,
                        friendly_name))


class RsyncTask(Task):
    def __init__(self, settings, hostname, info):
        Task.__init__(self)
        out_path = os.path.join(settings['root'], 'rsync',
                hostname.split('.')[0])
        self.command = [sys.executable, RSYNCBACKUP, '-v', hostname, out_path]
        for mount in info['mounts']:
            self.command.extend(['-m', mount])
        for rule in chain(settings.get('rsync-exclude', []),
                info.get('exclude', [])):
            self.command.extend(['-x', rule])
        if 'pre' in info:
            self.command.extend(['--pre', info['pre']])
        if 'post' in info:
            self.command.extend(['--post', info['post']])


class RsyncSource(Source):
    LABEL = 'rsync'

    def __init__(self, config, options):
        Source.__init__(self, config)
        for hostname, info in self._manifest.items():
            self._queue.put(RsyncTask(self._settings, hostname, info))


class CodaTask(Task):
    def __init__(self, settings, server, volume):
        Task.__init__(self)
        out_path = os.path.join(settings['root'], 'coda',
                server.split('.')[0], volume)
        self.command = [sys.executable, CODABACKUP, '-v', server, volume,
                out_path]
        if random.random() >= settings.get('coda-full-probability', 0.143):
            self.command.append('-i')


class CodaSource(Source):
    LABEL = 'coda'

    def __init__(self, config, options):
        Source.__init__(self, config)
        for group in self._manifest:
            for volume in group['volumes']:
                for server in group['servers']:
                    self._queue.put(CodaTask(self._settings, server, volume))


def run_tasks(config, options, source_names):
    source_map = Source.get_sources()
    sources = []
    for name in source_names:
        source = source_map[name](config, options)
        source.start()
        sources.append(source)
    for source in sources:
        source.wait()


def create_snapshot(settings):
    today = date.today().strftime('%Y%m%d')
    backup_lv = settings['backup-lv']
    vg = backup_lv.split('/')[0]
    with open('/dev/null', 'r+') as null:
        # Give up eventually in case test keeps failing
        for n in range(1, 100):
            snapshot_lv = '%s-%d' % (today, n)
            ret = subprocess.call(['sudo', 'lvs',
                    '%s/%s' % (vg, snapshot_lv)], stdout=null, stderr=null)
            if ret:
                break
        else:
            raise Exception("Couldn't locate unused snapshot LV")
    subprocess.check_call(['sudo', 'lvcreate', '-s', backup_lv, '-p', 'r',
            '-n', snapshot_lv])


if __name__ == '__main__':
    parser = OptionParser(usage='Usage: %prog [options] <config_path>')
    parser.add_option('-o', '--opt', dest='options', action='append',
            default=[],
            help='option string for source drivers')
    source_list = ', '.join(sorted(Source.get_sources()))
    parser.add_option('-s', '--source', dest='sources', action='append',
            default=[],
            help='backup source to enable (%s)' % source_list)
    parser.add_option('-S', '--no-snapshot', dest='snapshot',
            action='store_false', default=True,
            help='skip snapshot of backup volume')

    (opts, args) = parser.parse_args()
    try:
        config_path = args[0]
    except IndexError:
        parser.error('Missing argument')

    with open(config_path) as fh:
        config = yaml.safe_load(fh)

    run_tasks(config, opts.options, opts.sources)
    if opts.snapshot:
        create_snapshot(config['settings'])
